# # Initialize

---

임의의 polynominal 함수 

~~~
f(X) = A_nX + A_n-1x + .... + A_0 (n은 임의의 상수) 
~~~

여기에서 n을 설정하고, 계수를 Random()을 이용하여 범위제한해 0,음수 나오도록) 생성한다.( n 설정시 원하는 차승+1)

그러면 n개의 값을 가지는 정수형 배열이 나오는데, 이의 인덱스 번호는 생성된 함수의 X의 차승과 같다.

*ex) n=5이면, 0번 인덱스 = x^0차 계수 .... n-1= 4번 인덱스 = x^4차 계수* 



이어서 입력한 데이터 값들의 X좌표를 정수로 제한한다. (입력 데이터의 갯수는 Z개)

이후 X좌표들을 순서대로 임의의 함수 f(X)에 넣어 값을 계산하고, 함수(f(X))에서 출력된 값과 입력한 Y의 값의 차를 구한다.

이를 10번 반복하여 한 세대의 유전자를 10개로 유지한다. (유전자는 계수를 갖고있는 배열)

# # Selection

---

함수의 출력값과 입력한 Y의 값의 차를 M이라하자.

여기에서 M이 임의로 정한 오차범위 -K<M<K 를 만족시킨다면, 해당 X좌표를 true처리한다. (만족하지 않을시 false)

10개의 함수 중 true의 갯수가 가장 큰 함수를 우수한 유전자로 선택한다. **(단, true의 갯수가 Z라면 종료.)**

만약 모든 유전자의 true가 존재하지 않는다면 서로 이웃한 i%2==0 일때의 i와 i+1을 서로 선택한다.

# # CrossOver

---

- true의 갯수가 가장 큰 함수가 선택된 경우 :

true의 가장 큰 함수를 우성 유전자라 하고, n/2를하여 이를 기준으로 삼아 0~n/2의 계수 값들을 복사하여 나머지 짝수번째에 해당하는 유전자들의 0 ~ n/2 인덱스에 붙여넣는다.

이후 우성유전자에서 기준점인 n+1/2 ~ n-1 복사하여 나머지 홀수번째에 해당하는 유전자들의 n+1/2 ~ n-1 에 붙여넣는다.

(*가장 큰 함수가 여러개이면 큰 함수들은 유지해주고, 위와 같은 방법으로 바로 인근의 이웃한 항, 짝수와 홀수에따라 적용하며, 다음 가장 큰 함수가 나올 때 까지 이전의 큰 함수의 값을 옮겨준다. )

- true의 갯수가 존재하지 않는 경우 (ture의 갯수가 모두 같은 경우) :

우열이 구분 되지 않는 경우이므로 반복문에서 i%2==0일때만 연산을 처리하고, 위와 동일한 방법으로 n/2를 기준으로 

택하고 i의  0 ~ n/2 계수 값들을 복사하여 i+1번째의  0 ~ n/2 의 계수 값들에 옮기고, i+1 의 n+1/2 ~ n-1 의 계수 값들을 i의 n+1/2 ~ n-1로 옮긴다.

# # Mutate

---

- 돌연변이율 : 1/10 	( 모집단크기인 10의 역수로 설정)

한 세대의 교차된 유전자들, 즉 계수 함수들이 10개로 유지되고 있으므로 돌연변이율에 의하여 1개는 돌연변이가 발생.

Random()을 이용하여 유전자 한 가지를 선택, 이후 선택된 유전자 배열 내 인덱스를 무작위로 선택, 마지막으로 해당 인덱스의 정보를 무작위로 변경한다.

 

# # LOOP

---

임의로 설정한 세대만큼 반복한다.

또한 반복중 위에 명시한대로 true의 갯수 = Z 이면 종료한다.
